#!/usr/bin/env python3
"""
Generate README.md from `library.bib`, grouped by tags (BibTeX `keywords` field).

- Keeps the README header until the marker: <!-- AUTOGENERATED: DO NOT EDIT BELOW THIS LINE -->
- Appends a per-tag section with entries sorted by author/year/title.
- Supports comma- or semicolon-separated keywords.

Requires: pip install bibtexparser
"""

import re
import sys
from pathlib import Path

try:
    import bibtexparser
except ImportError:
    sys.stderr.write("Missing dependency: bibtexparser. Install with `pip install bibtexparser`\n")
    sys.exit(1)

ROOT = Path(__file__).resolve().parents[1]
BIB_PATH = ROOT / "library.bib"
README_PATH = ROOT / "README.md"
MARKER = "<!-- AUTOGENERATED: DO NOT EDIT BELOW THIS LINE -->"

def normalize_keywords(value: str):
    if not value:
        return []
    # split on comma or semicolon, strip whitespace, drop empties, lower-case for grouping but keep display as Title Case
    raw = re.split(r"[;,]", value)
    cleaned = [w.strip() for w in raw if w.strip()]
    # Return a tuple of (group_key, display_label)
    return [(w.lower(), w.strip()) for w in cleaned]

def citekey_link(key: str):
    # Anchor for quick linking inside README
    return f"<a id='{key}'></a>"

def format_authors(persons):
    if not persons:
        return ""
    # Persons typically like: "Last, First and Last2, First2"
    parts = [p.strip() for p in re.split(r"\s+and\s+", persons)]
    if len(parts) == 1:
        return parts[0]
    if len(parts) == 2:
        return f"{parts[0]} & {parts[1]}"
    return f"{parts[0]} et al."

def entry_sort_key(e):
    author = e.get("author","").lower()
    year = e.get("year","9999")
    title = e.get("title","").lower()
    return (author, year, title)

def entry_to_md(e):
    key = e.get("ID", "")
    typ = e.get("ENTRYTYPE","").capitalize()
    title = e.get("title","").strip(" {}")
    authors = format_authors(e.get("author",""))
    year = e.get("year","")
    venue = e.get("journal") or e.get("booktitle") or e.get("publisher") or ""
    doi = e.get("doi","").strip()
    url = e.get("url","").strip()

    bits = []
    if title:
        bits.append(f"**{title}**")
    meta = []
    if authors: meta.append(authors)
    if year: meta.append(str(year))
    if venue: meta.append(venue)
    if typ: meta.append(typ)
    if meta:
        bits.append(" — " + ", ".join(meta))

    tail = []
    if doi:
        tail.append(f"DOI: [{doi}](https://doi.org/{doi})")
    if url:
        tail.append(f"[Link]({url})")

    md = f"- {citekey_link(key)}" + " ".join(bits)
    if tail:
        md += " · " + " · ".join(tail)
    return md

def main():
    if not BIB_PATH.exists():
        sys.stderr.write(f"Missing {BIB_PATH}. Export your library to BibTeX as 'library.bib'.\n")
        sys.exit(1)

    with open(BIB_PATH, "r", encoding="utf-8") as f:
        db = bibtexparser.load(f)

    # Group entries by (normalized) tag
    groups = {}  # {group_key: {"label": display_label, "entries":[...]}}
    untagged = []

    for e in db.entries:
        kws = normalize_keywords(e.get("keywords","") or e.get("keyword",""))
        if not kws:
            untagged.append(e)
        else:
            # preserve each original display label casing per tag; prefer Title Case
            for gkey, label in kws:
                display = label.title()
                groups.setdefault(gkey, {"label": display, "entries": []})
                groups[gkey]["entries"].append(e)

    # Sort groups by display label
    ordered_groups = sorted(groups.values(), key=lambda g: g["label"].lower())

    # Build markdown body
    body = []
    body.append("## Tag index\n")
    if ordered_groups:
        idx = " · ".join(f"[{g['label']}](#{g['label'].lower().replace(' ', '-')})" for g in ordered_groups)
        body.append(idx + "\n")

    for g in ordered_groups:
        body.append(f"\n### {g['label']}\n")
        for e in sorted(g["entries"], key=entry_sort_key):
            body.append(entry_to_md(e))

    if untagged:
        body.append("\n### (Untagged)\n")
        for e in sorted(untagged, key=entry_sort_key):
            body.append(entry_to_md(e))

    generated = "\n".join(body).rstrip() + "\n"

    # Merge into README
    if README_PATH.exists():
        original = README_PATH.read_text(encoding="utf-8")
        if MARKER in original:
            head = original.split(MARKER, 1)[0].rstrip()
            final = head + "\n\n" + MARKER + "\n\n" + generated
        else:
            # Append marker if missing
            final = original.rstrip() + "\n\n" + MARKER + "\n\n" + generated
    else:
        # Minimal header if README missing
        final = f"# Reference Library\n\n---\n\n{MARKER}\n\n{generated}"

    README_PATH.write_text(final, encoding="utf-8")
    print(f"Wrote grouped list to {README_PATH}")

if __name__ == "__main__":
    main()
